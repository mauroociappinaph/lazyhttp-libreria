#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "üêô Verificando si se deben crear issues en GitHub..."

# Configuraci√≥n - Ajusta estos valores seg√∫n tu repositorio
GITHUB_REPO="mauroociappina/lazyhttp-libreria"
GITHUB_TOKEN_FILE=".github-token" # Archivo con tu token (no commitear)

# Verificar si existe el token
if [ ! -f "$GITHUB_TOKEN_FILE" ]; then
  echo "‚ö†Ô∏è No se encontr√≥ archivo de token de GitHub ($GITHUB_TOKEN_FILE)"
  echo "üí° Para habilitar la creaci√≥n autom√°tica de issues:"
  echo "   1. Crea un Personal Access Token en GitHub"
  echo "   2. Gu√°rdalo en $GITHUB_TOKEN_FILE"
  echo "   3. Agrega $GITHUB_TOKEN_FILE a .gitignore"
  exit 0
fi

GITHUB_TOKEN=$(cat "$GITHUB_TOKEN_FILE")

# Funci√≥n para crear issue en GitHub
create_github_issue() {
  local title="$1"
  local body="$2"
  local labels="$3"

  curl -s -X POST \
    -H "Authorization: token $GITHUB_TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$GITHUB_REPO/issues" \
    -d "{
      \"title\": \"$title\",
      \"body\": \"$body\",
      \"labels\": [$labels]
    }" > /dev/null

  if [ $? -eq 0 ]; then
    echo "‚úÖ Issue creado: $title"
  else
    echo "‚ùå Error creando issue: $title"
  fi
}

# Obtener archivos modificados en el √∫ltimo commit
MODIFIED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD)

# 1. Detectar TODOs y FIXMEs
echo "üîç Buscando TODOs y FIXMEs..."
for file in $MODIFIED_FILES; do
  if [ -f "$file" ] && [[ "$file" =~ \.(ts|js|tsx|jsx)$ ]]; then
    # Buscar TODOs
    grep -n "TODO\|FIXME\|HACK\|XXX" "$file" | while read -r line; do
      line_number=$(echo "$line" | cut -d: -f1)
      content=$(echo "$line" | cut -d: -f2- | sed 's/^[[:space:]]*//')

      # Extraer el comentario limpio
      clean_comment=$(echo "$content" | sed 's|//||g' | sed 's|/\*||g' | sed 's|\*/||g' | sed 's/^[[:space:]]*//')

      if [[ "$clean_comment" =~ TODO|FIXME|HACK|XXX ]]; then
        title="[AUTO] $(echo "$clean_comment" | head -c 50)..."
        body="**Archivo:** \`$file\` (l√≠nea $line_number)

**Comentario encontrado:**
\`\`\`
$clean_comment
\`\`\`

**Commit:** $(git rev-parse --short HEAD)
**Autor:** $(git log -1 --pretty=format:'%an')
**Fecha:** $(date)

---
*Issue creado autom√°ticamente por hook post-commit*"

        create_github_issue "$title" "$body" "\"todo\", \"auto-generated\""
      fi
    done
  fi
done

# 2. Detectar console.log en producci√≥n
echo "üîç Buscando console.log en archivos de producci√≥n..."
for file in $MODIFIED_FILES; do
  if [ -f "$file" ] && [[ "$file" =~ \.(ts|js)$ ]] && [[ ! "$file" =~ test|spec ]]; then
    if grep -q "console\.log\|console\.error\|console\.warn" "$file"; then
      title="[AUTO] Console statements found in production code"
      body="**Archivo:** \`$file\`

Se encontraron declaraciones de console en c√≥digo de producci√≥n que deber√≠an ser removidas.

**Commit:** $(git rev-parse --short HEAD)
**Autor:** $(git log -1 --pretty=format:'%an')

**L√≠neas encontradas:**
\`\`\`
$(grep -n "console\." "$file")
\`\`\`

---
*Issue creado autom√°ticamente por hook post-commit*"

      create_github_issue "$title" "$body" "\"bug\", \"cleanup\", \"auto-generated\""
    fi
  fi
done

# 3. Detectar dependencias con vulnerabilidades
echo "üîç Verificando vulnerabilidades en dependencias..."
if command -v pnpm >/dev/null 2>&1; then
  AUDIT_OUTPUT=$(pnpm audit --json 2>/dev/null || echo "")
  if [ ! -z "$AUDIT_OUTPUT" ] && echo "$AUDIT_OUTPUT" | grep -q "vulnerabilities"; then
    VULN_COUNT=$(echo "$AUDIT_OUTPUT" | grep -o '"vulnerabilities":[0-9]*' | cut -d: -f2)
    if [ "$VULN_COUNT" -gt 0 ]; then
      title="[AUTO] Security vulnerabilities detected in dependencies"
      body="Se detectaron $VULN_COUNT vulnerabilidades en las dependencias del proyecto.

**Commit:** $(git rev-parse --short HEAD)
**Fecha:** $(date)

**Acci√≥n recomendada:**
\`\`\`bash
pnpm audit
pnpm audit --fix
\`\`\`

---
*Issue creado autom√°ticamente por hook post-commit*"

      create_github_issue "$title" "$body" "\"security\", \"dependencies\", \"auto-generated\""
    fi
  fi
fi

# 4. Detectar archivos grandes (>100KB)
echo "üîç Verificando archivos grandes..."
for file in $MODIFIED_FILES; do
  if [ -f "$file" ]; then
    file_size=$(wc -c < "$file")
    if [ "$file_size" -gt 102400 ]; then # 100KB
      title="[AUTO] Large file detected: $(basename "$file")"
      body="**Archivo:** \`$file\`
**Tama√±o:** $(($file_size / 1024))KB

Se detect√≥ un archivo grande que podr√≠a afectar el rendimiento del repositorio.

**Commit:** $(git rev-parse --short HEAD)
**Autor:** $(git log -1 --pretty=format:'%an')

**Considerar:**
- ¬øEs necesario este archivo en el repositorio?
- ¬øDeber√≠a estar en .gitignore?
- ¬øSe puede optimizar o comprimir?

---
*Issue creado autom√°ticamente por hook post-commit*"

      create_github_issue "$title" "$body" "\"performance\", \"cleanup\", \"auto-generated\""
    fi
  fi
done

echo "üéâ Verificaci√≥n de issues autom√°ticos completada"
