# ğŸ“˜ Reglas de Desarrollo para HTTPLazy

Este archivo contiene guÃ­as y mejores prÃ¡cticas para mantener la calidad, escalabilidad y arquitectura del cÃ³digo mientras se desarrolla la biblioteca `httplazy`.

---

## ğŸ“ Estructura de CÃ³digo y OrganizaciÃ³n

- Organizar cÃ³digo en mÃ³dulos por dominio funcional (`auth`, `cache`, `core`, etc.).
- Usar estructura de sub-barriles para exportaciones (`index.ts` en subcarpetas).
- Colocar nuevas funcionalidades en el dominio apropiado, o crear uno nuevo si no existe.

---

## ğŸ§© ModularizaciÃ³n

- Dividir funcionalidades complejas en funciones auxiliares reutilizables.
- Extraer lÃ³gica interna en helpers, utils o adaptadores por dominio.
- Evitar mezclar lÃ³gica de mÃºltiples dominios en un solo mÃ³dulo.
- Aplicar el principio de responsabilidad Ãºnica (SRP) en cada archivo o funciÃ³n.
- Mantener interfaces claras entre mÃ³dulos y usar dependencias explÃ­citas.

---

## ğŸŒ² OptimizaciÃ³n para Tree-Shaking

- Usar solo exportaciones nombradas (`export { x }`), evitar `export default`.
- Evitar reexportaciones completas sin filtrado.
- Usar importaciones selectivas (`import { X } from './y'`).
- Mantener los consumidores de la librerÃ­a con importaciones especÃ­ficas.

---

## ğŸ” PrevenciÃ³n de Dependencias Circulares

- Mantener separaciÃ³n clara entre capas/mÃ³dulos.
- Usar inyecciÃ³n de dependencias donde aplique.
- Ejecutar `npx madge --circular ./src` periÃ³dicamente.
- Evitar que mÃ³dulos de bajo nivel dependan de alto nivel.
- Utilizar interfaces para desacoplar implementaciones.

---

## ğŸ”— Claridad en Relaciones de Dependencia

- Actualizar documentaciÃ³n de barriles/sub-barriles al modificarlos.
- Mantener comentarios explicativos en zonas de importaciones.
- Usar `JSDoc` para documentar propÃ³sito de mÃ³dulos y dependencias.
- Agrupar importaciones por dominio o categorÃ­a funcional.
- Evitar importaciones opacas o sin contexto.

---

## ğŸ§ª Control de Calidad y Mantenimiento

- Ejecutar `npx tsc` antes de cada commit para verificar los tipos.
- Mantener cobertura de pruebas adecuada para nuevas funcionalidades.
- Documentar APIs pÃºblicas con comentarios y ejemplos de uso.
- Actualizar el `README.md` al agregar nuevas funcionalidades.
- Ejecutar anÃ¡lisis de dependencias periÃ³dicamente.

---

## ğŸ”¤ Convenciones de Nomenclatura

- `PascalCase` para clases e interfaces.
- `camelCase` para variables, funciones y mÃ©todos.
- `UPPER_CASE` para constantes.
- Prefijos `I` o `T` opcionales si aportan claridad (`IUser`, `TOptions`).
- Mantener consistencia con el estilo existente del proyecto.

---

## âš™ï¸ Estilo de CÃ³digo

- Evitar duplicaciÃ³n de lÃ³gica o estructuras repetidas.
- Utilizar nombres de variables con verbos auxiliares (`isLoading`, `hasData`, `canRetry`, etc.).

---

## ğŸ’» Uso de TypeScript

- Todo el cÃ³digo debe escribirse en TypeScript.
- Preferir `interface` sobre `type` para estructuras de datos.
- Todas las funciones deben estar tipadas explÃ­citamente.
- Las interfaces deben residir en un archivo separado llamado .http-interface dentro de una carpeta.

## Principios de DiseÃ±o

- Priorizar cÃ³digo legible sobre cÃ³digo â€œcleverâ€.

## Versionado y Cambios

- Seguir Conventional Commits para los mensajes: feat:, fix:, refactor:, docs:, etc.

## ğŸ”„ Pruebas Automatizadas

- Usar jest para pruebas unitarias.

## ConvenciÃ³n de Archivos de Test

- Ubicar los tests junto al cÃ³digo (foo.test.ts) o en /**tests**/, pero de forma consistente.
- Usar mocks y fixtures aislados por dominio (**mocks**/, fixtures/).

## OrganizaciÃ³n por Dominio

- Cada carpeta de nivel superior debe representar un dominio funcional (por ejemplo: http/, cache/, auth/, core/, utils/).
- Dentro de cada dominio: Separar services, adapters, types, helpers, tests, etc.
- Mantener cada dominio autÃ³nomo: evitar que un dominio dependa directamente de la implementaciÃ³n interna de otro.

## Barrel Files (Sub-barriles)

- Usar index.ts en cada subdirectorio para exponer solo la API pÃºblica de ese mÃ³dulo.
- Evitar reexportar todo con export \*; exportar explÃ­citamente lo necesario.
- Un archivo index.ts nunca debe importar algo desde otro index.ts para evitar ambigÃ¼edades circulares.

## ğŸš« Capas Prohibidas

- No permitir imports cruzados entre submÃ³dulos sin pasar por el barrel correspondiente.
- âŒ import { x } from '../../auth/helpers/x'
- âœ… import { x } from '@/auth'
- Las capas â€œmÃ¡s externasâ€ no deben depender de capas â€œmÃ¡s internasâ€ directamente. Aplicar inversiÃ³n de dependencias cuando sea necesario.

## ğŸ§© CohesiÃ³n de Archivos

- Cada archivo debe tener una Ãºnica responsabilidad.
- No mezclar mÃºltiples funcionalidades o conceptos en un solo archivo.
- Los archivos grandes deben dividirse si alcanzan +200 lÃ­neas, usando helpers u otros mÃ³dulos.

## ğŸ§  Naming del Ãrbol

- El nombre de cada carpeta debe dejar en claro quÃ© hace, no cÃ³mo lo hace.
- âœ… cache/, http/, auth/
- âŒ utils/ genÃ©ricos (solo usar si son helpers compartidos y bien tipados)
- Preferir nombres en singular si el contenido representa una unidad (adapter, service, type, handler).

## Cargas CÃ­clicas

- Evitar Ã¡rboles de importaciones con ciclos.
- Validar la arquitectura con herramientas como madge regularmente.
